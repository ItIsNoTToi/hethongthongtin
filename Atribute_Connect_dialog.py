# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Atribute_ConnectDialog
                                 A QGIS plugin
 Xây dựng Plugin đọc và liên kết bảng dữ liệu thuộc tính với 1 lớp dữ liệu không gian
(vector) có sẵn và export ra bảng dữ liệu mới với các thuộc tính liên kết để thống kê báo cáo
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-11-14
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Group2
        email                : giangvanhung2003@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os 
import pandas as pd 
import matplotlib.pyplot as plt

from PyQt5.QtWidgets import QDialog, QFileDialog, QTableWidgetItem, QMessageBox 
from PyQt5 import uic, QtWidgets 
from qgis.core import QgsVectorLayer, QgsProject, QgsField
from PyQt5.QtCore import Qt 
from dbfread import DBF 
from xml.etree import ElementTree as ET
from .linked_dialog import link_Dialog

def read_dbf_file(file_path):
    """Đọc tệp .dbf và trả về DataFrame của pandas."""
    try:
        table = DBF(file_path, load=True, encoding='utf-8')  # Đọc tệp DBF
        data = [dict(record) for record in table]  # Chuyển sang danh sách dict
        df = pd.DataFrame(data)  # Chuyển sang DataFrame
        return df
    except UnicodeDecodeError as e:
        print(f"Error decoding file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading DBF file {file_path}: {e}")
        return None

def read_dbf_xml(file_path): 
    """Đọc file .dbf.xml và trả về cấu trúc dữ liệu XML.""" 
    try:
        tree = ET.parse(file_path) 
        root = tree.getroot() 
        return root
    except UnicodeDecodeError as e:
        print(f"Error decoding file {file_path}: {e}")
        return None
    

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Atribute_Connect_dialog_base.ui'))


class Atribute_ConnectDialog(QtWidgets.QDialog, FORM_CLASS):


    def __init__(self, parent=None):
        """Constructor."""
        super(Atribute_ConnectDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # module
        self.btn_ChonLopDuLieuKhongGIan.clicked.connect(self.select_vector_layer) 
        self.btn_ChonBangDuLieuThuocTinh.clicked.connect(self.select_attribute_table) 
        self.btn_LienKet.clicked.connect(self.link_attributes) 
        
        '''self.btn_export.clicked.connect(self.export_result) 
        self.btn_statistics.clicked.connect(self.show_statistics)'''

        self.vector_layer = None 
        self.attribute_data = None

    def select_vector_layer(self): 
        """Chọn lớp dữ liệu không gian (Vector).""" 
        vector_layer, _ = QFileDialog.getOpenFileName(self, "Chọn lớp dữ liệu không gian", "", "All files (*);;GeoJSON files (*.geojson);;Shapefiles (*.shp)") 
        if vector_layer: 
            self.vector_layer = QgsVectorLayer(vector_layer, "Layer", "ogr") 
            if not self.vector_layer.isValid(): 
                QMessageBox.critical(self, "Lỗi", "Không thể tải lớp dữ liệu không gian!") 
                return 
            fields = self.vector_layer.fields() 
            self.cmb_TruongKetHop.clear() 
            for field in fields: 
                self.cmb_TruongKetHop.addItem(field.name()) 
                self.show_tableWidget(self.vector_layer)

    def select_attribute_table(self):
        """Chọn bảng dữ liệu thuộc tính."""
        attribute_table, _ = QFileDialog.getOpenFileName(self, "Chọn bảng dữ liệu thuộc tính", "", 
                                                        "All files (*);;XML files (*.xml,*dbf.xml,*.shp.xml);;DBF files (*.dbf);;CSV files (*.csv);;Excel files (*.xlsx,*.xls)")
        if attribute_table:
            # Xử lý các định dạng file
            if attribute_table.endswith('.dbf'):
                self.attribute_data = read_dbf_file(attribute_table)
            elif attribute_table.endswith('.xml'):
                self.attribute_data = pd.read_xml(attribute_table)
            elif attribute_table.endswith('.csv'):
                self.attribute_data = pd.read_csv(attribute_table)
            elif attribute_table.endswith('.xlsx') or attribute_table.endswith('.xls'):
                self.attribute_data = pd.read_excel(attribute_table)
            else:
                QMessageBox.warning(self, "Lỗi", "Chỉ hỗ trợ định dạng DBF, CSV và Excel.")
                return
            
            if self.attribute_data is not None and not self.attribute_data.empty:
                self.show_attribute_table()
                self.cmb_TruongDich.clear()
                for col in self.attribute_data.columns:
                    self.cmb_TruongDich.addItem(col)
            else:
                QMessageBox.warning(self, "Lỗi", "Bảng dữ liệu thuộc tính trống.")

    def link_attributes(self):
        if not self.vector_layer or self.attribute_data is None:
            QMessageBox.warning(self, "Lỗi", "Vui lòng chọn lớp dữ liệu không gian và bảng dữ liệu thuộc tính trước.")
            return

        link_field = self.cmb_TruongKetHop.currentText()
        attr_field = self.cmb_TruongDich.currentText()
        if not link_field or not attr_field:
            QMessageBox.warning(self, "Lỗi", "Vui lòng chọn trường liên kết.")
            return

        try:
            spatial_data = pd.DataFrame([feature.attributes() for feature in self.vector_layer.getFeatures()], 
                                        columns=[field.name() for field in self.vector_layer.fields()])
            matched_data = pd.merge(spatial_data, self.attribute_data, left_on=link_field, right_on=attr_field, how='inner')

            if matched_data.empty:
                QMessageBox.warning(self, "Lỗi", "Không có dữ liệu trùng khớp.")
            else:
                self.show_linked_result(matched_data)
                QMessageBox.information(self, "Thành công", "Dữ liệu đã được liên kết!")
        except KeyError as e:
            QMessageBox.warning(self, "Lỗi", f"Trường không hợp lệ: {str(e)}")
        except Exception as e:
            QMessageBox.critical(self, "Lỗi", f"Đã xảy ra lỗi: {str(e)}")


    def show_linked_result(self, matched_data):
        """Hiển thị bảng kết quả liên kết trong giao diện."""
        # Tạo cửa sổ mới để hiển thị kết quả
        if matched_data is not None and not matched_data.empty:
            self.tb_BLK.setRowCount(0)
            self.tb_BLK.setColumnCount(len(matched_data.columns))
            self.tb_BLK.setHorizontalHeaderLabels(matched_data.columns)

            for index, row in matched_data.iterrows():
                row_position = self.tb_BLK.rowCount()
                self.tb_BLK.insertRow(row_position)
                for col, value in enumerate(row):
                    self.tb_BLK.setItem(row_position, col, QTableWidgetItem(str(value)))

        result_window = link_Dialog(self, matched_data)
        result_window.show()

    def show_tableWidget(self, layer): 
        """Hiển thị bảng dữ liệu thuộc tính của lớp không gian.""" 
        fields = layer.fields() 
        features = layer.getFeatures() 
        self.tb_LKG.setRowCount(0) 
        self.tb_LKG.setColumnCount(len(fields)) 
        self.tb_LKG.setHorizontalHeaderLabels([field.name() for field in fields]) 
        for feature in features: 
            row_position = self.tb_LKG.rowCount() 
            self.tb_LKG.insertRow(row_position) 
            for col, field in enumerate(fields): 
                value = feature[field.name()] 
                self.tb_LKG.setItem(row_position, col, QTableWidgetItem(str(value))) 
                
    def show_attribute_table(self):
        """Hiển thị bảng dữ liệu thuộc tính vào tableWidget."""
        if self.attribute_data is not None and not self.attribute_data.empty:
            self.tb_BTT.setRowCount(0)
            self.tb_BTT.setColumnCount(len(self.attribute_data.columns))
            self.tb_BTT.setHorizontalHeaderLabels(self.attribute_data.columns)

            for index, row in self.attribute_data.iterrows():
                row_position = self.tb_BTT.rowCount()
                self.tb_BTT.insertRow(row_position)
                for col, value in enumerate(row):
                    self.tb_BTT.setItem(row_position, col, QTableWidgetItem(str(value)))



    '''def export_result(self): 
        """Xuất kết quả thống kê.""" 
        output_file, _ = QFileDialog.getSaveFileName(self, "Lưu kết quả", "", "CSV files (*.csv)") 
        if not output_file: 
            return
        
        result_data = [] 
        fields = self.vector_layer.fields() 
        for feature in self.vector_layer.getFeatures(): 
            row = [feature[field.name()] for field in fields] 
            result_data.append(row) 

        df_result = pd.DataFrame(result_data, columns=[field.name() for field in fields]) 
        df_result.to_csv(output_file, index=False) 
        QMessageBox.information(self, "Thành công", "Kết quả đã được lưu thành công!") 

    def show_statistics(self):
        """Hiển thị bảng và đồ thị thống kê."""
        selected_field = self.comboBox_solieucanthongke.currentText()
        category_field = self.comboBox_danhmuc.currentText()
        agg_function = self.comboBox_hamthongke.currentText()

        if not selected_field or not category_field or not agg_function:
            QMessageBox.warning(self, "Lỗi", "Vui lòng chọn trường số liệu, danh mục và hàm thống kê.")
            return

        # Tính toán thống kê
        if agg_function == 'count':
            stats = self.attribute_data.groupby(category_field)[selected_field].count()
        elif agg_function == 'sum':
            stats = self.attribute_data.groupby(category_field)[selected_field].sum()
        # Bạn có thể thêm các hàm thống kê khác như mean, median, v.v.

        # Hiển thị kết quả dạng bảng
        self.tableWidget_3.setRowCount(0)
        self.tableWidget_3.setColumnCount(2)
        self.tableWidget_3.setHorizontalHeaderLabels([category_field, agg_function])

        for idx, (cat, val) in enumerate(stats.items()):
            self.tableWidget_3.insertRow(idx)
            self.tableWidget_3.setItem(idx, 0, QTableWidgetItem(str(cat)))
            self.tableWidget_3.setItem(idx, 1, QTableWidgetItem(str(val)))

        # Hiển thị kết quả dạng đồ thị
        plt.figure()
        stats.plot(kind='bar')
        plt.title(f'{agg_function} of {selected_field} by {category_field}')
        plt.xlabel(category_field)
        plt.ylabel(selected_field)
        plt.show()
        '''