# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Atribute_ConnectDialog
                                 A QGIS plugin
 Xây dựng Plugin đọc và liên kết bảng dữ liệu thuộc tính với 1 lớp dữ liệu không gian
(vector) có sẵn và export ra bảng dữ liệu mới với các thuộc tính liên kết để thống kê báo cáo
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-11-14
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Group2
        email                : giangvanhung2003@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os 
import pandas as pd 
import matplotlib.pyplot as plt

from PyQt5.QtWidgets import *
from PyQt5 import uic, QtWidgets 
from qgis.core import QgsVectorLayer, QgsProject, QgsField
from PyQt5.QtCore import Qt 
from dbfread import DBF 
from xml.etree import ElementTree as ET
from .linked_dialog import link_Dialog

def read_dbf_file(file_path):
    """Đọc tệp .dbf và trả về DataFrame của pandas."""
    try:
        table = DBF(file_path, load=True, encoding='utf-8')  # Đọc tệp DBF
        data = [dict(record) for record in table]  # Chuyển sang danh sách dict
        df = pd.DataFrame(data)  # Chuyển sang DataFrame
        return df
    except UnicodeDecodeError as e:
        print(f"Error decoding file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading DBF file {file_path}: {e}")
        return None

def read_dbf_xml(file_path): 
    """Đọc file .dbf.xml và trả về cấu trúc dữ liệu XML.""" 
    try:
        tree = ET.parse(file_path) 
        root = tree.getroot() 
        return root
    except UnicodeDecodeError as e:
        print(f"Error decoding file {file_path}: {e}")
        return None
    

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Atribute_Connect_dialog_base.ui'))


class Atribute_ConnectDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(Atribute_ConnectDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # module
        self.btn_ChonLopDuLieuKhongGIan.clicked.connect(self.select_vector_layer) 
        self.btn_ChonBangDuLieuThuocTinh.clicked.connect(self.select_attribute_table) 
        self.btn_LienKet.clicked.connect(self.link_attributes) 
        self.btn_statistics.clicked.connect(lambda: self.show_linked_result(self.linked_data))
        self.btn_export.clicked.connect(self.export_result) 

        self.checkboxes = {}  # Lưu trữ các checkbox theo tên
        self.group_box = QGroupBox(self)  # GroupBox
        self.layout = QVBoxLayout(self.group_box)  # Layout của GroupBox
        self.DuLieuLienKet.setWidget(self.group_box)
        self.DuLieuLienKet.setWidgetResizable(True)
       
        self.tb_BLK.cellClicked.connect(lambda row, col: self.update_line_edit(self.tb_BLK, row, col)) 
        self.tb_LKG.cellClicked.connect(lambda row, col: self.update_line_edit(self.tb_LKG, row, col)) 
        self.tb_BTT.cellClicked.connect(lambda row, col: self.update_line_edit(self.tb_BTT, row, col)) 
        self.lineEdit.editingFinished.connect(self.update_table_cell)

        self.vector_layer = None 
        self.attribute_data = None
        # dữ liệu sau lên kết
        self.linked_data = None

        # Lưu thông tin bảng, dòng, cột hiện tại
        self.current_table = None
        self.current_row = -1
        self.current_col = -1

    def select_vector_layer(self): 
        """Chọn lớp dữ liệu không gian (Vector).""" 
        vector_layer, _ = QFileDialog.getOpenFileName(self, "Chọn lớp dữ liệu không gian", "", "All files (*);;GeoJSON files (*.geojson);;Shapefiles (*.shp)") 
        if vector_layer: 
            self.vector_layer = QgsVectorLayer(vector_layer, "Layer", "ogr") 
            if not self.vector_layer.isValid(): 
                QMessageBox.critical(self, "Lỗi", "Không thể tải lớp dữ liệu không gian!") 
                return 
            fields = self.vector_layer.fields() 
            self.cmb_TruongKetHop.clear() 
            for field in fields: 
                self.cmb_TruongKetHop.addItem(field.name()) 
                self.show_tableWidget(self.vector_layer)

    def select_attribute_table(self):
        """Chọn bảng dữ liệu thuộc tính."""
        attribute_table, _ = QFileDialog.getOpenFileName(self, "Chọn bảng dữ liệu thuộc tính", "", 
                                                        "All files (*);;XML files (*.xml,*dbf.xml,*.shp.xml);;DBF files (*.dbf);;CSV files (*.csv);;Excel files (*.xlsx,*.xls)")
        if attribute_table:
            # Xử lý các định dạng file
            if attribute_table.endswith('.dbf'):
                self.attribute_data = read_dbf_file(attribute_table)
            elif attribute_table.endswith('.xml'):
                self.attribute_data = pd.read_xml(attribute_table)
            elif attribute_table.endswith('.csv'):
                self.attribute_data = pd.read_csv(attribute_table)
            elif attribute_table.endswith('.xlsx') or attribute_table.endswith('.xls'):
                self.attribute_data = pd.read_excel(attribute_table)
            else:
                self.show_warning("Lỗi", "Chỉ hỗ trợ định dạng DBF, CSV và Excel.")
                return
            
            if self.attribute_data is not None and not self.attribute_data.empty:
                self.show_attribute_table()
                self.cmb_TruongDich.clear()

                self.clear_all_checkboxes()

                for col in self.attribute_data.columns:
                    self.cmb_TruongDich.addItem(col)
                    self.add_checkbox(col)
            else:
                self.show_warning("Lỗi", "Bảng dữ liệu thuộc tính trống.")

    def add_checkbox(self, field_name):
        """Thêm một checkbox vào ScrollArea."""
        if field_name not in self.checkboxes:
            checkbox = QCheckBox(field_name, self.group_box)
            self.layout.addWidget(checkbox)  # Thêm checkbox vào layout
            self.checkboxes[field_name] = checkbox  # Lưu checkbox theo tên trường

    def get_selected_fields(self):
        """Lấy danh sách các trường được chọn."""
        return [
            field_name
            for field_name, checkbox in self.checkboxes.items()
            if checkbox.isChecked()
        ]
    
    def clear_all_checkboxes(self):
        """Xóa tất cả các thành phần (làm mới giao diện)."""
        # Xóa các checkbox trong layout
        for field_name, checkbox in self.checkboxes.items():
            checkbox.setParent(None)  # Loại bỏ checkbox khỏi giao diện

        # Xóa từ điển checkboxes
        self.checkboxes.clear()
        
    def link_attributes(self):
        """Liên kết dữ liệu thuộc tính với lớp dữ liệu không gian."""
        if not self.vector_layer or self.attribute_data is None:
            self.show_warning("Lỗi", "Vui lòng chọn lớp dữ liệu không gian và bảng dữ liệu thuộc tính trước.")
            return

        link_field = self.cmb_TruongKetHop.currentText()
        attr_field = self.cmb_TruongDich.currentText()
        link_item_fields = self.get_selected_fields()

        # Nếu không chọn các trường liên kết cụ thể, lấy toàn bộ cột từ bảng thuộc tính
        if not link_item_fields or len(link_item_fields) == 0:
            link_item_fields = self.attribute_data.columns.tolist()

        if not link_field or not attr_field:
            self.show_warning("Lỗi", "Vui lòng chọn trường liên kết.")
            return

        spatial_data = []
        
        # Thu thập dữ liệu không gian từ lớp vector và chuyển thành DataFrame
        spatial_data = pd.DataFrame([feature.attributes() for feature in self.vector_layer.getFeatures()], 
                                        columns=[field.name() for field in self.vector_layer.fields()])

        try:
            # Kết hợp dữ liệu không gian và dữ liệu thuộc tính
            matched_data = pd.merge(
                spatial_data,
                self.attribute_data,
                left_on=link_field,
                right_on=attr_field,
                how='inner'
            )
        except KeyError as e:
            self.show_warning("Lỗi", f"Không thể kết nối các trường: {str(e)}")
            return

        # Kiểm tra kết quả sau khi kết hợp dữ liệu
        if matched_data.empty:
            self.show_warning("Lỗi", "Không có dữ liệu trùng khớp giữa lớp không gian và bảng dữ liệu thuộc tính.")
            return

        # Nếu dữ liệu kết hợp thành công, hiển thị kết quả
        QMessageBox.information(self, "Thành công", "Dữ liệu đã được liên kết thành công!")
        print("Kết quả liên kết:")
        print(matched_data)

        # Hiển thị kết quả kết hợp
        self.linked_data = matched_data
        self.show_linked_table()
        self.show_linked_result(matched_data)

    def show_linked_result(self, linked_data):
        """Hiển thị bảng kết quả liên kết trong giao diện."""
        if linked_data is None:
            QMessageBox.information(self, "Lỗi", "Dữ liệu liên kết trống. Vui lòng thực hiện liên kết trước.")
            return
        print(linked_data)
        
        # Tạo cửa sổ mới để hiển thị kết quả
        result_window = link_Dialog(self, linked_data)
        result_window.show()

    def show_tableWidget(self, layer): 
        """Hiển thị bảng dữ liệu thuộc tính của lớp không gian.""" 
        fields = layer.fields() 
        features = layer.getFeatures() 
        self.tb_LKG.setRowCount(0) 
        self.tb_LKG.setColumnCount(len(fields)) 
        self.tb_LKG.setHorizontalHeaderLabels([field.name() for field in fields]) 
        for feature in features: 
            row_position = self.tb_LKG.rowCount() 
            self.tb_LKG.insertRow(row_position) 
            for col, field in enumerate(fields): 
                value = feature[field.name()] 
                self.tb_LKG.setItem(row_position, col, QTableWidgetItem(str(value)))
                
    def show_attribute_table(self):
        """Hiển thị bảng dữ liệu thuộc tính vào tb_BTT."""
        if self.attribute_data is not None and not self.attribute_data.empty:
            self.tb_BTT.setRowCount(0)
            self.tb_BTT.setColumnCount(len(self.attribute_data.columns))
            self.tb_BTT.setHorizontalHeaderLabels(self.attribute_data.columns)

            for index, row in self.attribute_data.iterrows():
                row_position = self.tb_BTT.rowCount()
                self.tb_BTT.insertRow(row_position)
                for col, value in enumerate(row):
                    self.tb_BTT.setItem(row_position, col, QTableWidgetItem(str(value)))

    def show_linked_table(self):
        """Hiển thị bảng dữ liệu sau khi được liên kết"""
        if self.linked_data is not None and not self.linked_data.empty:
            self.tb_BLK.setRowCount(0)
            self.tb_BLK.setColumnCount(len(self.linked_data.columns))
            self.tb_BLK.setHorizontalHeaderLabels(self.linked_data.columns)

            for index, row in self.linked_data.iterrows():
                row_position = self.tb_BLK.rowCount()
                self.tb_BLK.insertRow(row_position)
                for col, value in enumerate(row):
                    self.tb_BLK.setItem(row_position, col, QTableWidgetItem(str(value)))      

    def show_warning(self, title, message):
        """
        Hiển thị một thông báo cảnh báo dạng dialog trong QGIS.

        Parameters:
            title: str
                Tiêu đề của thông báo.
            message: str
                Nội dung của thông báo.
        """
        msg_box = QMessageBox()
        msg_box.setIcon(QMessageBox.Warning)
        msg_box.setWindowTitle(title)
        msg_box.setText(message)
        msg_box.setStandardButtons(QMessageBox.Ok)
        msg_box.exec_()

    def update_line_edit(self, table, row, col):
        """Cập nhật QLineEdit với giá trị từ ô được chọn."""
        item = table.item(row, col)
        if item:
            self.lineEdit.setText(item.text())
        else:
            self.lineEdit.clear()

        # Lưu thông tin bảng, dòng, cột hiện tại
        self.current_table = table
        self.current_row = row
        self.current_col = col

    def update_table_cell(self):
        """Cập nhật giá trị từ QLineEdit vào ô hiện tại."""
        if self.current_table and self.current_row >= 0 and self.current_col >= 0:
            new_value = self.lineEdit.text()
            self.current_table.setItem(self.current_row, self.current_col, QTableWidgetItem(new_value))

    def export_result(self):
        self.export_to_excel(self.linked_data, "Bang dữ liệu liệu liên kết")

    def export_to_excel(self, data, fileName = "Excel"):
        """
        Xuất dữ liệu DataFrame sang tệp Excel, cho phép người dùng chọn nơi lưu.

        Parameters:
            data: DataFrame
                Dữ liệu cần xuất.
        """
        if data is not None and not data.empty:
            try:
                options = QFileDialog.Options()
                file_path, _ = QFileDialog.getSaveFileName(
                    self, 
                    "Chọn nơi lưu tệp " + fileName, 
                    "", 
                    "Excel Files (*.xlsx);;All Files (*)", 
                    options=options
                )
                if file_path:
                    data.to_excel(file_path, index=False)
                    QMessageBox.information(self, "Thành công", f"Dữ liệu đã được xuất ra tệp {file_path}")
                else:
                    QMessageBox.warning(self, "Lỗi", "Đã huỷ chọn nơi lưu tệp")
            except Exception as e:
                QMessageBox.warning(self, "Lỗi", f"Xuất dữ liệu thất bại: {str(e)}")
        else:
            QMessageBox.warning(self, "Lỗi", "Không có dữ liệu để xuất")